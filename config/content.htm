<h1>About</h1>
<p>請各組員趕緊加入評分要求的相關說明</p>
<p>pj3第四組</p>
<p></p>
<p>網頁:<a href="https://mdecd2023.github.io/2a3-pj3ag4/content/index.html">https://mdecd2023.github.io/2a3-pj3ag4/content/index.html</a> </p>
<p>倉儲:<a href="https://github.com/mdecd2023/2a3-pj3ag4">https://github.com/mdecd2023/2a3-pj3ag4</a> </p>
<p></p>
<p><span>41023104</span></p>
<p><span><a href="http://[2001:288:6004:17:2023:cda:4:1]:23020/">http://[2001:288:6004:17:2023:cda:4:1]:23020/</a> <br/></span></p>
<p><span>41023112 </span></p>
<p><span><a href="http://[2001:288:6004:17:2023:cda:4:2]:23020/">http://[2001:288:6004:17:2023:cda:4:2]:23020/</a> <br/></span></p>
<p><span>41023121</span></p>
<p><span><a href="http://[2001:288:6004:17:2023:cda:4:3]:23020/">http://[2001:288:6004:17:2023:cda:4:3]:23020/</a> <br/></span></p>
<p><span>41023134</span></p>
<p><span><a href="http://[2001:288:6004:17:2023:cda:4:4]:23020/">http://[2001:288:6004:17:2023:cda:4:4]:23020/</a> <br/></span></p>
<p><span>41023143</span></p>
<p><span><a href="http://[2001:288:6004:17:2023:cda:4:5]:23020/">http://[2001:288:6004:17:2023:cda:4:5]:23020/</a> <br/></span></p>
<p>41023146(組長)</p>
<p><a href="http://[2001:288:6004:17:2023:cda:4:6]:23020/">http://[2001:288:6004:17:2023:cda:4:6]:23020/</a></p>
<p>41023147</p>
<p><a href="http://[2001:288:6004:17:2023:cda:4:7]:23020/">http://[2001:288:6004:17:2023:cda:4:7]:23020/</a></p>
<p>41023148</p>
<p><a href="http://[2001:288:6004:17:2023:cda:4:8]:23020/">http://[2001:288:6004:17:2023:cda:4:8]:23020/</a></p>
<h1>jitsi</h1>
<h2>協同過程</h2>
<p>一<strong>.0515協同過程</strong></p>
<p><strong>    </strong>1.分配PJ3的任務:</p>
<p>        41023146:負責目標2,3,4<span>,</span>7</p>
<p>        41023147,41023143:負責目標4,5</p>
<p>        41023112,41023104:負責目標6</p>
<p>        41023148:負責目標1,6</p>
<p>        41023121,41023134:負責簡報</p>
<p><strong></strong></p>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/f3FYJpjT1Bg" title="YouTube video player" width="560"></iframe></p>
<p>二,0528協同過程</p>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/AnaKvIxGCP0" title="YouTube video player" width="560"></iframe></p>
<p></p>
<p>==</p><h1>pj3</h1>
<p><span style="background-color: #ffff00;"><strong>pj3目標:</strong></span></p>
<p><strong>1.場景中的計時器(.ttm)(✅)</strong></p>
<p><strong>2.添加球員擊球技能、球員倒地再站起</strong></p>
<p><strong>3.球進球框不刪除改收集(圖檔已完成、只缺更改名稱的函式)(✅)</strong></p>
<p><strong>4.球員移動優化(例如:前進可以加右轉一起)(✅)</strong></p>
<p><strong>5.設計球員新外型(✅)</strong></p>
<p><strong>6.另外以建立以機械轉盤傳動計分系統(.ttm)</strong></p>
<p><strong>7.將記分板系統改為.ttm格式(✅)</strong></p>
<p><strong>---</strong></p>
<p><b>完成進度:</b></p>
<p><strong>1.第七點完成</strong>(<a href="/downloads/pj3ag4_zmq_bubbleRob1.7z">pj3ag4_zmq_bubbleRob1.7z</a>, <a href="/downloads/scoreboard.ttm">scoreboard.ttm</a>)</p>
<p> ◉scoreboard.ttm中不含感測器只要將場景中感測器改名為sensor1、sensor2就可以用了(要跟board同一層)</p>
<p><strong>2.第三點完成</strong>(<a href="/downloads/pj3ag4_zmq_bubbleRob2.7z">pj3ag4_zmq_bubbleRob2.7z</a>)</p>
<p> ◉將sim.removeObject(ball)---刪除球 改為 sim.setObjectAlias(ball, 'ball')---將球改名(球原本名稱為Sphere)</p>
<p><strong>3.第五點完成</strong>(<a href="/downloads/brickRob.ttm">brickRob.ttm</a>)</p>
<p> ◉將原本車體改為磚塊型，除了解決車體本身會倒的問題之外，還將前進原理更改為四軸驅動，使轉彎更為順暢及合理。</p>
<p><img alt="" height="315" src="/images/brickRob.png" width="560"/></p>
<p><strong>4.第四點完成</strong>(<a href="/downloads/brickRob.7z">brickRob.7z</a>) 延伸更新:(<a href="/downloads/brickRob2.7z">brickRob2.7z</a>)</p>
<p><span> ◉將原本上相左右同時只能執行一個,改為前後可跟左右一起執行,操作性有很大的提升</span></p>
<p> <span>◉延伸更新為第二種車體運作方式，其原理為更改整個車體角度使其變換方向</span></p>
<p><span><strong>5.第六點半完成</strong>(<a href="/downloads/機械計分板.rar">機械計分板.rar</a>&amp;<a href="/downloads/機械記分板.ttt">機械記分板.ttt</a>)</span></p>
<p><span> ◉CoppeliaSim4.3.0和CoppeliaSim4.5的版本不相容<a href="/downloads/嘗試啟動記分板.ttt">嘗試啟動記分板.ttt</a>是使用4.3.3版本開啟的齒輪之間會有所卡頓還需改正齒輪外型</span></p>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/jwPj4D0m6MQ" title="YouTube video player" width="560"></iframe></p>
<p><span></span></p>
<p><span> ◉</span>將圖檔重畫後再重新導進<span>CoppeliaSim中,將齒輪的質量和慣性矩調整後即可順利運行</span></p>
<p><span><strong>6.修改尺寸並將磚塊型車體導入場景</strong>(<a href="/downloads/zmq_brickRob1.7z">zmq_brickRob1.7z</a>)</span></p>
<p><span> ◉修改足球大小</span></p>
<p><span> ◉更改感測器位置</span></p>
<p><strong>7.完成計時器及調整計分板顏色</strong>(<a href="/downloads/timer.ttm">timer.ttm</a>,<a href="/downloads/scoreboard2.ttm">scoreboard2.ttm</a>)</p>
<p><span> ◉利用sim.getSimulationTime()函數獲得模擬時間並配合記分板程式,完成實體計時器製作</span></p>
<p> ◉將計分板改為黑底白字(將程式修改為停止模擬時分數歸零)</p>
<p><strong>8.更改球員外型</strong>(<a href="/downloads/player.7z">player.7z</a>)</p>
<p><span> ◉添加球員手部</span></p>
<p><span> ◉球員本體用導入的開啟碰撞會抖動，所以我加入skin物件(球員外型)然後將本體隱藏</span></p>
<p><span><strong>9.新機械計分板零件包</strong>(<a href="/downloads/48scoreboard.zip">48scoreboard.zip</a>)</span></p>
<p><span> ◉導入場景(<a href="/downloads/scoreboard3.ttt">scoreboard3.ttt</a><span> </span><a href="/downloads/scoreboard3.ttm">scoreboard3.ttm</a><span>)</span></span></p>
<p><strong>10.整合所有物件</strong>(<a href="/downloads/zmq_football.7z">zmq_football.7z</a>)(未完成)</p>
<p> <span>◉將計時器、球員、場地、記分板、機械記分板導入</span></p>
<p> <span>◉添加八個球員的控制程式</span></p>
<p><strong>11.添加背號及空氣牆及zmq_IPv6</strong>(<a href="/downloads/zmq_football2.7z">zmq_football2.7z</a>)</p>
<p></p>
<p><strong>12.機械式記分板lua</strong><strong>程式</strong>(<a href="/downloads/m_scoreboard.ttm">m_scoreboard.ttm</a>,<a href="/downloads/zmq_football3.7z">zmq_football3.7z</a>)</p>
<p><span> </span><span>◉添加機械式計分版程式利用sim.getJointTargetPosition()</span></p>
<p><span></span>獲取計分版角度再用<span>sim.setJointTargetPosition()更改角度</span></p>
<p><span><strong>13.在解決問題二的過程中因為轉矩調過大導致出現了能夠托馬斯迴旋的功能</strong>(<a href="/downloads/player problem1.ttt">player problem1.ttt</a>,<a href="/downloads/player problem1.ttm">player problem1.ttm</a>)</span></p>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/BEJIMr3QHeI" title="YouTube video player" width="560"></iframe></p>
<p><span> </span></p>
<p><span><strong>14.更改外型</strong>(<a href="/downloads/player2.ttt">player2.ttt</a>,<a href="/downloads/player.ttm">player.ttm</a>)</span></p>
<p><span> <span>◉</span>解決翻車問題，增加本體的質量<br/></span></p>
<p><strong>15.自訂IPv6位置設定過程</strong></p>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/OpGsRX-sQPE" title="YouTube video player" width="560"></iframe></p>
<p></p>
<p><strong>16.統整場景</strong>(<a href="/downloads/zmq_football4.7z">zmq_football4.7z</a>)</p>
<p><span> </span><span>◉將新的球員外型導入</span></p>
<p><span> <span>◉因球員的質量有調整(變重),所以在場地上會晃動</span></span></p>
<p><span><span> <span>◉將場地分解並改為無碰撞,並將場地移至比實體地板高一點點,這樣球員會在地板上移動,看起來在球場上,並且球員輪子有一點點陷入球場,像是草皮</span></span></span></p>
<p><span><span><span> <span>◉更改球門顏色,並改為碰撞</span></span></span></span></p>
<p><strong>17.將球員程式添加倒地翻身</strong>(<a href="/downloads/a_player1.py">a_player1.py</a>)</p>
<p><strong>18.簡化球員python程式</strong>(<a href="/downloads/zmq_football/player.py">player.py</a>)</p>
<p><span> </span><span>◉將'/a_player'設為變數player使更改操控的球員更容易,只要改變數player,速度也作了同樣的改動</span></p>
<p><span><strong>19.將簡化程式及翻身程式統整</strong>(<a href="/downloads/zmq_football5.7z">zmq_football5.7z</a>)<br/></span></p>
<p><span> <span>◉將17及18點導入</span></span></p>
<p><span><span> <span>◉將翻身程式按鍵改成空白建</span></span></span></p>
<p><span> <span>◉刪除a_player1~b_player4.py程式</span></span></p>
<p></p><h2>Detail</h2>
<p>在執行協同產品設計專案的過程, 透過 Github 倉儲可以有效採分散式版次管理的流程儲存多名組員各自分工所完成的內容.</p>
<p>然而在執行過程中, 會在不同時段產生不同性質的心得, 若要以內容管理的方式分章節式的架構儲存資料, 則可使用網站分頁的方式記錄.</p>
<p>若要採關鍵字, 特定主題或日記式的流程紀錄, 則可以使用網誌進行記錄. 由於 cmsimde 內建 Pelican blog 架構, 並且利用 Leo Editor 建立產生網誌的 Markdown 文章檔案. 假如多人共用同一個 .leo 專案檔, 則必須要在 XML 架構中進行多人資料版本的衝突解決, 此舉由於 Leo Editor 標註非常多元且屬性繁多, 因此在解決衝突過程, 非常容易造成無法回復原貌的 .leo 檔案.</p>
<p>因此, 使用 Leo Editor 維護網誌時, 建議每位組員在倉儲 users 目錄下專有一個 .leo 檔案, 且標示學號, 各組員每次改版, 原則上只編輯各自的 .leo 檔案, 而所產生位於 markdown 目錄中的 .md 檔案則也建議除了標示日期外, 也標示學號, 若各組員間交錯編輯 markdown 目錄中的 .md 檔案, 也僅需要在衝突產生時, 針對 .md 進行處理, 而無需針對 .leo 檔案進行衝突處理.</p>
<p>至於網際簡報檔案, 也建議各組員採相同模式, 將 config/reveal.leo 各複製一份至 users 目錄下針對 reveal 目錄下的簡報網頁進行編輯與衝突處理.</p>
<h3>Repository</h3>
<p>修改 init.py 將網站標題改為 2a3-pj3ag4</p>
<p>建立 server_admin.py 使用 8140 port 但只用於 cad2 主機, 請勿在 stud2 主機中啟用</p>
<p>參與協同設計專案的所有成員應該都必須充分了解為何要使用 Git 與網際內容管理系統</p>
<p style="padding-left: 30px;">假如針對開會討論以外的事項, 各組員希望導入測試用的內容, 無論是 LaTeX, 開發程式, 簡報或網站內容, 都可以開 branch 進行測試, 若在隨後的會議取得共識, 再將測試的內容合併至 main branch</p>
<h3>CAD</h3>
<p>在場景中所使用的所有零組件, 都應該要交代構想, 設計與繪圖流程, 並說明所使用的套件, 最後再提供各種格式的檔案下載, 若單一檔案超過 20MB, 則建議放入可以公開的 GDrive 或 OneDrive, 並提供下載連結.</p>
<h3>Lua</h3>
<p>CoppeliaSim 的本體是採用 C++ 與 Qt 編寫, 並利用 Lua 來進行彈性設定與功能延伸, 將 Lua 寫在 .ttt 或 .ttm 中的好處是容易打包, 但在改版過程則沒有文字檔格式的改版資料, 因此較好的開發模式為:</p>
<p>在開發過程可以利用導入的方式將 Lua 程式放在 .ttt 之外, 等到最後要打包 .ttm 或 .ttt 時再將最後結果置入.</p>
<h3>Python</h3>
<p>Legacy Python remote API 因為其效能無法與 zmqRemoteAPI 比較, 因此隨後的 remoteAPI 都將採用 zmq 的方式進行控制, 利用 Python 進行控制過程, 必須要能呈現不同改版的差異, 並在程式中詳加說明.</p>
<p>一來讓其他參考的分組或組員可以充分了解, 二來也可以在日後自己參考或延伸應用時, 以最短時間進入狀況.</p>
<h3>Models</h3>
<p>在場景中所建立的各種 .ttm, 除了要詳細說明如何從 CAD 建立模型, 轉入 CoppeliaSim, 然後進行簡化與相關設定外, 還要提供檔案下載, 說明建立此模型的成員學號等資料, 最後再利用 .git 動畫檔案說明模型特定等.</p>
<p>因為目前最新的 cmsimde 為了讓手機拍攝的影像檔案能夠在上傳之前進行 resize, 因此破壞原有 .gif 檔案的動態特性.</p>
<p>這個問題尚未解決之前, 若要導入 .gif, 必須設法直接將檔案送到 images 目錄後再行引用. 例如: 可以直接在 Github 倉儲直接將 .gif 檔案 upload 到 images 目錄後, 然後在近端或中端伺服器中, 以 git pull 拉下後引用.</p>
<p><img alt="" height="268" src="/images/mechanical_counter_demo.gif" width="400"/></p>
<h3>Scenes</h3>
<p>有關各版次所完成的場景與控制程式, 必須詳細說明各版本的差異 (即 release statement), 也可在團隊間學習如何使用 cmsimde 的 peliacan blog 與 reveal presentation, 而最後則必須學習如何在各組員同步編輯 LaTeX 內容的流程中, 完成 pj3 專案報告 pdf 檔案.</p>
<h2>STL</h2>
<p></p>
<p>1.球員皮膚圖檔(<a href="/downloads/STL/skin.7z">skin.7z</a>)</p>
<p><img alt="" height="193" src="/images/skin.jpg" width="343"/></p>
<h2>scoreboard</h2>
<p><strong>機械記分板製作過程</strong></p>
<p>1.繪圖,參考以下影片進行繪製,縮減為十位數</p>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/iURFrmwIMPc" title="YouTube video player" width="560"></iframe></p>
<h1>details</h1>
<h2>連線說明</h2>
<p><span style="background-color: #ffff00;">zmq連線設定(41023147)</span></p>
<p>1.將防火牆關閉(三個都關掉)</p>
<p><img alt="" height="315" src="/images/01.png" width="560"/></p>
<p>2.點擊進階設定</p>
<p><img alt="" height="315" src="/images/02.png" width="421"/></p>
<p>3.組長點擊輸入規則，組員則點擊輸出規則</p>
<p><img alt="" height="315" src="/images/03.png" width="421"/></p>
<p>4.接著點選新增規則，點選連接埠，規則選擇TCP，接著設定特定<span>連接埠</span>為23000-23050</p>
<p><img alt="" height="315" src="/images/04.png" width="441"/></p>
<p>5.選擇允許連線</p>
<p><img alt="" height="315" src="/images/05.png" width="419"/></p>
<p>6.接著設定名稱</p>
<p><img alt="" height="315" src="/images/06.png" width="421"/></p>
<p>7.接著設定老師規定的IPv6位置</p>
<p><img alt="" height="315" src="/images/07.png" width="548"/></p>
<p>8.接著將各組的zmq打開，注意zmq以及CoppeliaSim(4.5.1)需選擇有支援IPv6的版本</p>
<p>(若版本不對可至<a href="https://mde.tw/cd2023/content/pj3.html">https://mde.tw/cd2023/content/pj3.html</a> 下載)</p>
<p><img alt="" height="315" src="/images/08.png" width="560"/></p>
<p>9.接著打上對應的組長IPv6位置並連線</p>
<p><img alt="" height="172" src="/images/09.png" width="560"/></p>
<p>10.接著在瀏覽器搜尋  <a href="http://[組長IP]:23020，ru6dk3ej0">http://[組長IP]:23020</a>  即可觀看組長場景並連線對戰</p>
<p>11.影片說明</p>
<p></p>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/OpGsRX-sQPE" title="YouTube video player" width="560"></iframe></p>
<h2>記分板製作</h2>
<p>1.齒輪式記分板(<a href="/downloads/gear scoreboard.zip">gear scoreboard.zip</a>)</p>
<p><img alt="" height="281" src="/images/2023-06-02.png" width="500"/></p>
<p>零件繪製過程</p>
<script>
var winkVideoData01 = {
  dataVersion: 1,
  frameRate: 10,
  buttonFrameLength: 5,
  buttonFrameOffset: 2,
  frameStops: {
  },
};
</script>
<div class="winkVideoContainerClass"><video autoplay="autoplay" class="winkVideoClass" controls="controls" data-dirname="/static" data-varname="winkVideoData01" height="281" muted="true" width="500">
<source src="/downloads/48.16.mp4" type="video/mp4"/></video>
<div class="winkVideoOverlayClass"></div>
<div class="winkVideoControlBarClass"><button class="winkVideoControlBarPlayButtonClass"></button> <button class="winkVideoControlBarPauseButtonClass"></button>
<div class="winkVideoControlBarProgressLeftClass"></div>
<div class="winkVideoControlBarProgressEmptyMiddleClass"></div>
<div class="winkVideoControlBarProgressRightClass"></div>
<div class="winkVideoControlBarProgressFilledMiddleClass"></div>
<div class="winkVideoControlBarProgressThumbClass"></div>
</div>
<div class="winkVideoPlayOverlayClass"></div>
</div>
<p>2.記分板(LED)(<a href="/downloads/scoreboard(LED).zip">scoreboard(LED).zip</a>)</p>
<p><img caption="false" height="282" src="/images/2023-05-03.png" width="500"/></p><h3>程式</h3>
<p>原記分板程式:</p>
<pre class="brush:lua;auto-links:false;toolbar:false" contenteditable="false">function sysCall_init()
    score1_1 = 0
    score1_2 = 0
    score1_3 = 0
    score1_4 = 0
    score2_1 = 0
    score2_2 = 0
    score2_3 = 0
    score2_4 = 0
    s0={1,1,1,0,1,1,1}
    s1={0,0,1,0,0,1,0}
    s2={1,0,1,1,1,0,1}
    s3={1,0,1,1,0,1,1}
    s4={0,1,1,1,0,1,0}
    s5={1,1,0,1,0,1,1}
    s6={1,1,0,1,1,1,1}
    s7={1,0,1,0,0,1,0}
    s8={1,1,1,1,1,1,1}
    s9={1,1,1,1,0,1,1}
   
    s={s0,s1,s2,s3,s4,s5,s6,s7,s8,s9}

    score(0,'a')
    score(0,'b')
    score(0,'c')
    score(0,'d')
end
</pre>
<p></p>
<p>首先sysCall_init()這是初始設定,也就是只會執行一次的函式</p>
<p>1.score1_1~2_4為得分的紀錄(後面會詳細講)</p>
<p>2.s0~s9為判斷變色的陣列,1為白色(亮)0為黑色(暗)(因為這個計分板式採用七段顯示器的原理)</p>
<p>3.s為二維陣列,中函s0~s9的陣列</p>
<p>4. score(0,'a'),score(0,'b'),score(0,'c'),score(0,'d')這個為將記分板數字設為零</p>
<pre class="brush:lua;auto-links:false;toolbar:false" contenteditable="false">function score(x,y)
    for i=0 ,9,1 do
        if (x==i)then
            for j = 0,6,1 do
                local part = sim.getObject('./'..y..''..j..'')
                if (s[i+1][j+1]==1) then
                    sim.setShapeColor(part, nil, sim.colorcomponent_ambient_diffuse, {1, 1, 1})
                else
                    sim.setShapeColor(part, nil, sim.colorcomponent_ambient_diffuse, {0, 0, 0})
                end
            end
        end
    end
end</pre>
<p></p>
<p>score這個函式是我自己添加的,作用是判斷分數是多少然後改變色,有兩個輸入值x為分數y為'a',<span>'b','c','d',分別代表記分板從左到右四個數字</span></p>
<p><span>函式中第一個for迴圈執行九次配合下面if函式可判輸入的分數為多少,且超過九就不會執行</span></p>
<p><span>其實可以直接從第二個for迴圈開始然後i改成x(因為這函式是從程式裡改出來的)</span></p>
<p><span>這個函式的重點是二維陣列配合if來判斷哪個部分需要亮哪個地方需要暗,然後用for迴圈執行七次將一個數字七個部位都上色</span></p>
<pre class="brush:lua;auto-links:false;toolbar:false" contenteditable="false">function sysCall_actuation()
    sensor1 = sim.getObject('/sensor1') --獲取sensor1的句柄
    sensor2 = sim.getObject('/sensor2') --獲取sensor2的句柄
    result1=sim.readProximitySensor(sensor1) --讀取接近傳感器的值，若有接觸返回值為一正數值
    result2=sim.readProximitySensor(sensor2)

    
    if(score1_1&lt;10)then --分數小於十
        if(result1&gt;0)then --感測器返回值大於零執行
            score1_2 = score1_1+1
            if(score1_2==10 and score1_3&lt;9)then
                score1_2=0 --等於十歸零
                score1_4=score1_3+1
            end
            local ball = sim.getObject('/Sphere')
            sim.setObjectSpecialProperty(ball, sim.modelproperty_not_detectable) --將物件的detectable關閉
            score(score1_4,'a')
            score(score1_2,'b')
            score1_1=score1_2
            score1_3=score1_4
        end
    else
        sim.pauseSimulation() --暫停
    end
    if(score2_1&lt;10)then
        if(result2&gt;0)then
            score2_2 = score2_1+1
            if(score2_2==10 and score2_3&lt;9)then
                score2_2=0
                score2_4=score2_3+1
            end
            local ball = sim.getObject('/Sphere')
            sim.setObjectSpecialProperty(ball, sim.modelproperty_not_detectable)
            score(score2_4,'c')
            score(score2_2,'d')
            score2_1=score2_2
            score2_3=score2_4
        end
    else
        sim.pauseSimulation()
    end
    p=sim.getSimulationState()
    if(p==22)then --若模擬停止則將記分板數字歸零
        score(0,'a')
        score(0,'b')
        score(0,'c')
        score(0,'d')
    end
end</pre>
<p>sysCall_actuation()為會一直重複執行的函式</p><h2>記分板導入coppeliasim詳細過程</h2>
<p>41023121李承翰</p>
<p>首先先導入STL檔</p>
<p><img alt="" height="280" src="/images/11.png" width="525"/></p>
<p>之後<span>將記分板記分板調整為須方向</span></p>
<p><img alt="" height="294" src="/images/12.png" width="281"/></p>
<p>調整位置由於動作過於基本這裡快速帶過</p>
<p><img alt="" height="330" src="/images/13.png" width="621"/></p>
<p>將其爆炸(分開)</p>
<p>做法:右鍵Edit&gt;Grouping/Merging&gt;Divide selected shapes</p>
<p><img alt="" height="545" src="/images/14.png" width="1069"/></p>
<p>調整數字顏色這個動作要重複20次將所有德數字都改成想要的顏色</p>
<p><img alt="" height="363" src="/images/15.png" width="504"/></p>
<p>完成後長這樣</p>
<p><img alt="" height="312" src="/images/16.png" width="323"/></p>
<p>由於剛剛沒發現記分板方向錯誤所以這裡再次翻轉記分板調整方向</p>
<p>特別的是在coppeliasim中可以使用shift加上滑鼠左鍵來拖動一次選取多個物件</p>
<p><img alt="" height="308" src="/images/17.png" width="513"/></p>
<p>之後是改名環節啦要將物件改為對應位置的數字以方便程式寫入</p>
<p><img alt="" height="664" src="/images/18.png" width="325"/></p>
<p>到此處的檔案<a href="/downloads/詳細過程講解1.ttt">詳細過程講解1.ttt</a></p>
<p>之後開始加入軸來讓齒輪運轉</p>
<p>首先先新增軸</p>
<p><img alt="" height="453" src="/images/19.png" width="513"/></p>
<p>之後調整軸的大小以方便觀察</p>
<p><img alt="" height="328" src="/images/20.png" width="371"/></p>
<p>旋轉x軸讓軸可以轉到需要的方向</p>
<p><img alt="" height="343" src="/images/21.png" width="480"/></p>
<p>這裡先選軸在選要對中心的物體</p>
<p><img alt="" height="311" src="/images/22.png" width="519"/></p>
<p>完成後長這樣</p>
<p><img alt="" height="210" src="/images/23.png" width="419"/></p>
<p>設定完後複製軸之後貼上兩次然後重複上個步驟調整位置</p>
<p><img alt="" height="454" src="/images/24.png" width="471"/></p>
<p>調整記分板顏色</p>
<p><img alt="" height="308" src="/images/25.png" width="428"/></p>
<p>之後開始調整個物件的依賴將齒輪依附到剛剛設定的軸上</p>
<p>再將齒輪依附到板子上</p>
<p>再將分數版依附到齒輪上</p>
<p><img alt="" height="718" src="/images/26.png" width="301"/></p>
<p>之後開始調整軸的轉動以方便檢查是否會卡住</p>
<p><img alt="" height="442" src="/images/27.png" width="448"/></p>
<p>這裡要注意除了主動軸其他軸也要設定轉速為0不然模擬時齒輪會隨意偏擺</p>
<p><img alt="" height="601" src="/images/28.png" width="620"/></p>
<p>之後調整它的質量和慣性矩</p>
<p><img alt="" height="606" src="/images/29.png" width="506"/></p>
<p><img alt="" height="447" src="/images/30.png" width="496"/></p>
<p>完成後記分板就能順利運轉啦</p>
<p><img alt="" height="541" src="/images/31.png" width="418"/></p>
<p>圖檔:<a href="/downloads/詳細過程講解2.ttt">詳細過程講解2.ttt</a></p>
<p>之後是轉成.ttm檔的教學</p>
<p>選擇一的面的物體雙擊找到model properties打勾</p>
<p><img alt="" height="328" src="/images/32.png" width="466"/></p>
<p>之後點選這裡重複兩次</p>
<p><img alt="" height="452" src="/images/33.png" width="556"/></p>
<p>會先跳出地板可以質借按no之後存取我們想要的物件按OK</p>
<p></p>
<p><img alt="" height="657" src="/images/34.png" width="759"/></p>
<p>之後記得到資料夾有沒有存成功喔</p>
<p>圖檔:<a href="/downloads/詳細過程講解.ttm">詳細過程講解.ttm</a></p><h2>球員倒地翻身</h2>
<p>添加球員倒地翻身程式(41023134)</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false"> elif keyboard.is_pressed('e'):
        floor= sim.getObject('/Floor')
        player = sim.getObject('/a_player1')
        a=sim.getObjectOrientation(player,floor)
        b=sim.getObjectPosition(player,floor)
        a[0]=0
        a[1]=0
        b[2]=b[2]+0.2
        sim.setObjectPosition(player,floor,b)
        sim.setObjectOrientation(player,floor,a)
       </pre>
<p>elif keyboard.is_pressed('e'):<br/>如果按"e"就執行</p>
<p><br/>floor= sim.getObject('/Floor')<br/>獲取地板的句柄</p>
<p><br/>player = sim.getObject('/a_player1')<br/>獲取球員的句柄</p>
<p><br/>a=sim.getObjectOrientation(player,floor)<br/>獲取相對於地板的球員方向</p>
<p><br/>b=sim.getObjectPosition(player,floor)<br/>獲取相對於地板的球員位置</p>
<p><br/>a[0]=0<br/>球員的x角度為0</p>
<p><br/>a[1]=0<br/>球員的y角度為0</p>
<p><br/>b[2]=b[2]+0.2<br/>球員的z位置上升0.2</p>
<p><br/>sim.setObjectPosition(player,floor,b)<br/>設定球員相對於地板的位置</p>
<p><br/>sim.setObjectOrientation(player,floor,a)<br/>設定球員相對於地板的方向</p>
<h2>球員程式</h2>
<p>球員程式製作(4102146)</p>
<p>設定球員輪子旋轉</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">def setVelocity(lfwV, rfwV,lbwV, rbwV):
    leftMotor1 = sim.getObject(player+'/joint_lf')
    rightMotor1 = sim.getObject(player+'/joint_rf')
    leftMotor2 = sim.getObject(player+'/joint_lb')
    rightMotor2 = sim.getObject(player+'/joint_rb')
    sim.setJointTargetVelocity(leftMotor1, lfwV)
    sim.setJointTargetVelocity(rightMotor1, rfwV)
    sim.setJointTargetVelocity(leftMotor2, lbwV)
    sim.setJointTargetVelocity(rightMotor2, rbwV)</pre>
<p>設定球員前輪方向</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">def setangel(y):
    ontology= sim.getObject(player)
    angel = [-90*math.pi/180, y*math.pi/180, 0*math.pi/180]
    leftMotor = sim.getObject(player+'/joint_lf')
    rightMotor = sim.getObject(player+'/joint_rf')
    sim.setObjectOrientation(leftMotor, ontology, angel)
    sim.setObjectOrientation(rightMotor, ontology, angel)</pre>
<p>按鍵控制球員左右轉</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">def controlangel(y):
    if keyboard.is_pressed('a'):
        setangel(-y)
    elif keyboard.is_pressed('d'):
        setangel(y)
    else:
        setangel(0)</pre>
<p><span>按鍵控制</span>球員程式(w,a,s,d,q)</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">def playercontrol(x,y):
    if keyboard.is_pressed('w'):
        setVelocity(x,x,x,x)
        controlangel(y)
    elif keyboard.is_pressed('s'):
        setVelocity(-x,-x,-x,-x)
        controlangel(y)
    elif keyboard.is_pressed('a'):
        setVelocity(-x,x,-x,x)
    elif keyboard.is_pressed('d'):
        setVelocity(x,-x,x,-x)
    elif keyboard.is_pressed('q'):
        # stop simulation
        sim.stopSimulation()
    else:
        setVelocity(0, 0, 0, 0)
        setangel(0)</pre>
<p>控制球員速度(主要在執行的部分,一直執行)</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">while True:
    if keyboard.is_pressed('shift'):
        playercontrol(v+4,a-20)
    else:
        playercontrol(v,a)</pre>
<p></p>